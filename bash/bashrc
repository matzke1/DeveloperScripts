# Robb's bash(1) initialization for both login and non-login shells.  -*- shell-script -*-
# The login shells source this file from one of the
# login initializaton files, usually ~/.bash_profile.

[ -f $HOME/.environment ] && . $HOME/.environment
[ -f $HOME/.bash_env ] && . $HOME/.bash_env

##############################################################################
# SHELL BEHAVIOR
##############################################################################

# Make sure user's bin directory is somewhere in the path.
# FIXME: This should probably be rewritten so as not to use a hard-coded
#        location for path-adjust.
eval $(~/bin/path-adjust insert ~/bin)

# Ignoring commands will cause prompt beeping to malfunction
export HISTCONTROL=
export HISTFILESIZE=100

# append to the history file, don't overwrite it
shopt -s histappend

# check the window size after each command and, if necessary, update the
# values of LINES and COLUMNS.
shopt -s checkwinsize

# Turn off this incredibly stupid autocompleting mode. Pressing TAB fails
# to list file names in many situations.
shopt -u progcomp

# Make sure system directories are in $MANPATH so if we add more paths
# later everything is still found.
export MANPATH=$(manpath 2>/dev/null)

##############################################################################
# PROMPT
##############################################################################

#LOLA="arborea 10145"

if [ -n "$PS1" ]; then

    # Should the prompt be colorized?
    PROMPT_USE_COLOR=
    if [ -n "$(type -p tput)" ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429).  Lack of such support is extremely rare, and such a
	# case would tend to support setf rather than setaf.)
	PROMPT_USE_COLOR=yes
    fi

    # Architecture name
    os=
    if [ -n "$SPOCK_SCRIPTS" ]; then
	os=$("$SPOCK_SCRIPTS/spock-os-name" --short)
    elif [ -n "$(which spock-shell)" ]; then
	os=$(spock-shell bash -c '$SPOCK_SCRIPTS/spock-os-name --short')
    fi
    [ -n "$os" ] && os="[$os]"
    
    # Do something in the prompt if the last command takes more than N seconds.
    command_prompt () {
	status=$?

	local old_histtimeformat="$HISTTIMEFORMAT"
	HISTTIMEFORMAT="%s "
	local start_time=$(history 1 | awk '{print $2}')
	HISTTIMEFORMAT="X-X-X"
	local cmd="$(history 1 |sed 's/.*X-X-X//')"
	HISTTIMEFORMAT="$old_histtimeformat"

	local cmd_name=$(command-name "$cmd")

	if [ -n "$start_time" ]; then
	    local stop_time=$(date "+%s")
	    local elapsed=$[stop_time - start_time]
	    if [ $elapsed -gt 15 ]; then
		sec_to_hms $elapsed >>/dev/tty
		local result_text=
		if [ -n "$cmd_name" ]; then
		    if [ "$status" -ne 0 ]; then
			result_text="$cmd_name failed after $(extended_hms $elapsed)"
		    else
			result_text="$cmd_name completed in $(extended_hms $elapsed)"
		    fi
		fi

		if [ -n "$result_text" ]; then
		    if [ -n "$LOLA" ]; then
			lola_say "$result_text"
		    elif [ -n "$(which notify-send)" ]; then
			notify-send "$result_text"
		    fi
		else
		    echo -en '\a' >&2
		fi
	    fi
	fi

	[ "$SHLVL" -gt 1 ] && echo "L$SHLVL "

    }

    prompt_xterm_title() {
	if [ "$TERM" = "xterm" ]; then
            local title="$USER@$(uname -n)"
	    echo -en '\033]2;'
	    echo -n "$title"
	    echo -en '\007'
	fi
    }

    prompt_git_info() {
	local branchname=$(git branch --no-color 2>/dev/null |sed -n 's/^\* *//p')
	[ -n "$branchname" ] && echo -n "$branchname "
    }

    prompt_color() {
	local string="$1" color="$2"
	[ -n "$color" ] && echo -n '\[\e['"$color"'m\]'
	echo -n "$string"
	[ -n "$color" ] && echo -n '\[\e[0m\]'
    }

    if (echo "$PS1" |grep command_prompt >/dev/null 2>&1); then
	: already set
    else
	PS1=
	PS1="$PS1"'$(command_prompt)'
	PS1="$PS1"'$(prompt_xterm_title)'
	PS1="$PS1$(prompt_color "\\u@\\h$os "        32)"
	PS1="$PS1$(prompt_color '\W '                33)"
	PS1="$PS1$(prompt_color '$(prompt_git_info)' 35)"
	PS1="$PS1$(prompt_color '$PS1_STACK'         31)"
	PS1="$PS1"'\n'"$(prompt_color '$ '           32)"

    fi


    # If we're running under "screen" then set the prompt stack
    [ -n "$STY" ] && PS1_STACK="screen $PS1_STACK"
fi

##############################################################################
# ALIASES
##############################################################################

if [ -n "$PS1" ]; then
    alias ll='ls -lhF '
    alias scr='screen -D -R -e^Hh'
    alias idea='env IDEA_JDK=/usr/lib/jvm/java-6-sun ~/idea-IC-133.696/bin/idea.sh'
    alias wi='exec ssh -X wisconsin'

    if [ -x /usr/bin/dircolors ]; then
	eval "`dircolors -b`"
	alias ls='ls --color=auto'
	alias grep='grep --color=auto'
	alias fgrep='fgrep --color=auto'
	alias egrep='egrep --color=auto'
    fi
fi

##############################################################################
# THIS MUST BE LAST!!!!
##############################################################################

# Move ~/bin to the front of $PATH
eval $(path-adjust insert --move --prepend ~/bin)
export PATH
