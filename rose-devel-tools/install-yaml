#!/bin/bash

# Install versions of the C++ YAML library
arg0="${0##*/}"

# Versions of yaml to install if they aren't installed already.
: ${YAML_VERSIONS:="0.5.1 0.5.2 0.5.3"}

# Versions of boost against which to compile yaml.
: ${BOOST_VERSIONS:="all"}

# Space-separated list of compilers to use as the "rmc_compiler" value.  These can be executable names or
# VENDOR-VERSION-LANGUAGE triplets.
: ${COMPILERS:="g++"}

# Directory where we build stuff. Using a local directory instead of NFS will speed things up.
: ${TEMPDIR:="$HOME/junk"}

# RMC toolchain directory where yaml will be installed.
: ${TOOLCHAIN:="$RMC_RMC_TOOLCHAIN"}
: ${TOOLCHAIN:="$HOME/GS-CAD"}

# Which cmake to use? This can be the word "system", a full path to the cmake executable, or an RMC-known version number.
: ${CMAKE_VERSION:="3.1.0"}

# If non-empty, then re-install yaml even if it seems to already be installed.
: REINSTALL


# Download source tarball into current working directory
get_source() {
    local version="$1" destination="$2"
    local remote="https://github.com/jbeder/yaml-cpp"
    local local_repo="$HOME/Downloads/yaml-cpp-$version"
    if [ ! -f "$HOME/Downloads/yaml-cpp-$version.tar.gz" ]; then
	rm -rf "$HOME/Downloads/yaml-cpp-$version"
	case "$version" in
	????????????????????????????????????????)
	    git clone "$remote" "$local_repo"
	    (cd "$local_repo" && git reset --hard "$version" && git clean -dfx)
	    ;;
	*)
	    git clone -b "release-$version" "$remote" "$local_repo"
	    ;;
	esac
	(cd "$local_repo" && git archive --format=tar --prefix="yaml-cpp-$version/" HEAD) |\
	    gzip > "$HOME/Downloads/yaml-cpp-$version.tar.gz"
	rm -rf "$HOME/Downloads/yaml-cpp-$version"
    fi
    ln -sf "$HOME/Downloads/yaml-cpp-$version.tar.gz" "$destination"
}

is_installed() {
    local prefix="$1"
    local hdr="$prefix/include/yaml-cpp/yaml.h"
    if [ ! -r "$hdr" ]; then
        echo "$arg0: failed to install (missing $hdr)" >&2
        return 1
    fi
    local lib="$prefix/lib/libyaml-cpp.so"
    if [ ! -r "$lib" ]; then
        echo "$arg0: failed to install (missing $lib)" >&2
        return 1
    fi
    return 0
}

if [ "$BOOST_VERSIONS" = "all" ]; then
    echo "$arg0: looking for boost versions (this may take a while)..."
    BOOST_VERSIONS=$(RMC_RMC_TOOLCHAIN="$TOOLCHAIN" rmc list --terse boost)
    echo "$arg0: boost versions: $BOOST_VERSIONS"
fi

for yaml_version in $YAML_VERSIONS; do
    for boost_version in $BOOST_VERSIONS; do
        for compiler in $COMPILERS; do
            (figlet -c "$yaml_version w/boost-$boost_version" || \
             banner "$yaml_version w/boost-$boost_version") 2>/dev/null

	    eval $(rmc clear)
	    export RMC_RMC_TOOLCHAIN="$TOOLCHAIN"
	    eval $(rmc resolve parallelism)
	    eval $(RMC_CXX_NAME="$compiler" RMC_BUILD_SYSTEM=cmake RMC_CMAKE_VERSION="$CMAKE_VERSION" rmc resolve --require cmake)
            eval $(RMC_CXX_NAME="$compiler" RMC_BOOST_VERSION="$boost_version" RMC_YAML_VERSION="$yaml_version" rmc resolve yaml)
	    [ "$RMC_CMAKE_FILE" = "" ] && continue
	    [ "$RMC_CXX_VENDOR" = "" -o "$RMC_CXX_VERSION" = "" -o "$RMC_CXX_LANGUAGE" = "" ] && continue
	    [ "$RMC_BOOST_ROOT" = "" ] && continue
	    [ "$RMC_YAML_ROOT" = "" ] && continue
	    export LD_LIBRARY_PATH=$(rmc vector prepend_or_leave "$RMC_RMC_LIBDIRS" : "$LD_LIBRARY_PATH")

            logfile="yaml-cpp-$yaml_version.log"
            date >"$logfile"
            echo "yaml-cpp-$yaml_version for $RMC_YAML_ROOT"
            echo "log file is " $(rmc realpath "$logfile")
	    if [ "$REINSTALL" != "" ]; then
		: install even if it looks to be installed
            elif is_installed "$RMC_YAML_ROOT" 2>/dev/null; then
                echo "already installed; skipping"
                echo "already installed; skipping" >>"$logfile"
                continue
            fi

	    temporary_prefix="$RMC_YAML_ROOT-$(date '+%Y%m%d')"

            mkdir -p "$TEMPDIR"
            (
                set -e
                cd "$TEMPDIR"

                echo "downloading yaml-cpp-$yaml_version..." >&2
                tarball="yaml-cpp-$yaml_version.tar.gz"
                get_source "$yaml_version" "$tarball"
                if [ ! -f "$tarball" ]; then
                    echo "$arg0: couldn't download $tarball" >&2
                    exit 1
                fi

                builddir="yaml-cpp-$yaml_version"
                echo "unpacking into $builddir..." >&2
                rm -rf "$builddir"
                tar xf "$tarball"
                if [ ! -d "$builddir" ]; then
                    echo "$arg0: unpacking failed for $tarball into $builddir" >&2
                    exit 1
                fi

                mkdir "$builddir/_build"
                cd "$builddir/_build"

		set -x
                "$RMC_CMAKE_FILE" .. \
		                  -DBUILD_SHARED_LIBS=Yes \
                                  -DCMAKE_CXX_COMPILER="$RMC_CXX_NAME" \
                                  -DCMAKE_CXX_FLAGS="$RMC_CXX_SWITCHES" \
                                  -DBOOST_ROOT="$RMC_BOOST_ROOT" \
                                  -DCMAKE_INSTALL_PREFIX="$temporary_prefix"

                make -j$RMC_PARALLELISM

                make install
		set +x

                is_installed "$temporary_prefix" || exit 1

		# Remove previous installation if any (only need to do this if the old installation is a directory rather
		# than a symlink.
		if [ ! -h "$RMC_YAML_ROOT" -a -d "$RMC_YAML_ROOT" ]; then
		    rm -rf "$RMC_YAML_ROOT.bak"
		    mv "$RMC_YAML_ROOT" "$RMC_YAML_ROOT.bak"
		else
		    rm -f "$RMC_YAML_ROOT"
		fi

		# Link in the new installation. The "-r" switch of "ln" is not always available, so do it the hard way.
		if false; then
		    ln -sfr "$temporary_prefix" "$RMC_YAML_ROOT"
		else
		    temporary_base=$(basename "$temporary_prefix")
		    real_base=$(basename "$RMC_YAML_ROOT")
		    dir="${temporary_prefix%/$temporary_base}"
		    (cd "$dir" && ln -sf "$temporary_base" "$real_base")
		fi
		is_installed "$RMC_YAML_ROOT" || exit 1

            ) 2>&1 |tee -a "$logfile"
	    mv "$logfile" "$RMC_YAML_ROOT/installation.log"
        done
    done
done
