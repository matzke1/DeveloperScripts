#!/bin/bash
arg0="${0##*/}"

rmc_help() {
    echo "usage $arg0 [GLOBAL_SWITCHES] COMMAND [ARGS...]"
    echo "   $arg0 is the ROSE Meta Configuration system whose purpose is to set up an environment for compiling and/or"
    echo "   using ROSE. The basic idea is that one creates a ROSE build directory, places an RMC configuration file in"
    echo "   that directory, and uses $arg0 to create a subshell (or run commands) in which certain environment variables"
    echo "   are initialized."
    echo
    echo "   The GLOBAL_SWITCHES are:"
    echo "       -C DIRECTORY"
    echo "           Change to DIRECTORY before doing anything else. DIRECTORY can be any directory in the build tree"
    echo "           since the $CONFIG_BASE_NAME configuration file is found by traversing upward until the root of the"
    echo "           build tree. This is useful for commands like '$arg0 -C DIRECTORY make' which runs 'make' in DIRECTORY"
    echo "           and also finds the configuration file, and is shorter than '$arg0 -C BUILD_ROOT make -C DIRECTORY'"
    echo "           but does essentially the same thing."
    echo "       --help | -h"
    echo "           Shows this documentation, or if a subcommand is specified, the documentation for that subcommand."
    echo "       --version | -V"
    echo "           Prints the RMC version number to standard output and exits."
    echo
    echo "    The following subcommands are implemented. Documentation for a subcommand is shown by running"
    echo "    '$arg0 --help COMMAND'."
    echo "        init     -- creates a stub $CONFIG_BASE_NAME configuration file in the current working directory."
    echo "        config   -- generates and runs ROSE's 'configure' command."
    echo "        make     -- runs an enhanced version of 'make' (multiple targets, parallelism, etc)."
    echo "        shell    -- starts a shell suitable for ROSE development."
    echo "        resolve  -- similar to 'shell' but emits shell commands to set environment variables instead."
    echo "        realpath -- expand symbolic links, '.', and '..' in file names."
    echo "        clear    -- emits a shell 'unset' command to clear all RMC environment variables."
    echo
    echo "    If no COMMAND is specified then 'shell' is assumed.  The $arg0 command can be nested. The author's mode"
    echo "    of operation is to create various build directories on a local filesystem that point to shared source"
    echo "    directories mounted with NFS.  He initializes the build directories with '$rmc init ROSE_SRC_DIR' (only"
    echo "    when first creating it) and enters a build environment by running '$rmc' anywhere in the build tree. To"
    echo "    configure ROSE he runs '$arg0 config' and builds with '$arg0 make-binary', which builds the ROSE library"
    echo "    and those tests and projects related to binary analysis. From within a non-build environment such as"
    echo "    Emacs, he compiles with '$arg0 -C DIRECTORY make' where DIRECTORY is any directory in the build tree."
}

# Convert a relative file name to an absolute file name while resolving symbolic links. This is defined here because we need
# it in order to find the rmc-function.sh file. For example, rmc might be installed in ~/bin (value of "$0") as a symbolic
# link to some other directory, and it's this other directory that contains all the supporting files.
rmc_realpath() {
    local path="$1"
    local debug=
    [ "$debug" = "" ] || echo "ROBB: rmc_relpath '$path'" >&2
    [ "${path#/}" = "$path" ] && path="$(pwd)/$path" # make it absolute

    # Split the name into components
    local old_IFS="$IFS"
    IFS="/"
    set - $path
    IFS="$old_IFS"
    local input=("$@");

    # Process components one at a time to build the output
    local output=()
    while [ "${#input[@]}" -gt 0 ]; do
        [ "$debug" = "" ] || echo "      input = ${input[*]}" >&2
        local in_part="${input[0]}"
        input=("${input[@]:1:${#input[@]}}") # shift first item off array
        [ "$debug" = "" ] || echo "        in_part='$in_part'" >&2

        # Append to the output name
        if [ "$in_part" = "." -o "$in_part" = "" ]; then
            continue
        elif [ "$in_part" = ".." ]; then
            [ ${#output[*]} -gt 0 ] && unset output[${#output[@]}-1]
            continue
        else
            output=("${output[@]}" "$in_part")
        fi

        # Output path
        local output_path="/$(IFS=/; echo "${output[*]}")"
        [ "$debug" = "" ] || echo "        output_path=$output_path" >&2

        # Handle symbolic links
        if [ -h "$output_path" ]; then
            local target_path=$(readlink "$output_path")
            [ "$debug" = "" ] || echo "        is a symbolic link to $target_path" >&2
            old_IFS="$IFS"
            IFS="/"
            set - $target_path
            IFS="$old_IFS"
            local target=("$@")
            [ "$debug" = "" ] || echo "        target parts = ${target[*]}" >&2

            input=("${target[@]}" "${input[@]}")
            if [ "${target_path#/}" = "$target_path" ]; then
                unset output[${#output[@]}-1] # link target is relative
            else
                output=() # link target is absolute
            fi
        fi
    done
    local result=$(IFS=/; echo "/${output[*]}")
    [ "$debug" = "" ] || echo "      result='$result'" >&2
    echo "$result"
}

# rmc subcommand to be executed; the first non-switch argument
COMMAND=

# Name of RMC configuration file to be found/created at the top of the build directory. The config is what causes rmc to create
# the same environment every time it runs in a particular build directory. The user is welcome to adjust the contents of this
# directory, but then he should also exit and re-enter the rmc environment so that the changes are picked up. He'll also maybe
# want to run ROSE's "build", "configure", and "make clean" steps after changing this file.
CONFIG_BASE_NAME=".rmc-main.cfg"

# All exported rmc environment variables begin with the letters "RMC_" followed by a module name. Module names are things like
# "BOOST", "YAML", etc.  Environment variables for rmc itself begin with "RMC_RMC_", like RMC_RMC_VERSION, which is the version
# number of rmc.
export RMC_RMC_VERSION="0.2.1"

# Load additional functionality. These files live in the same directory as this script.
arg0_realname=$(rmc_realpath $0)
source ${arg0_realname%/*}/rmc-support/functions.sh || exit 1

# RMC modules
source ${arg0_realname%/*}/rmc-support/modules/autoconf.sh    	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/boost.sh       	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/build.sh       	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/compiler.sh    	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/code_coverage.sh || exit 1
source ${arg0_realname%/*}/rmc-support/modules/cmake.sh       	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/dlib.sh        	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/doxygen.sh     	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/edg.sh         	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/jvm.sh         	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/magic.sh       	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/misc.sh        	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/os.sh          	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/parallelism.sh 	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/python.sh      	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/qt.sh          	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/readline.sh    	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/rose.sh        	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/rosebld.sh     	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/rosesrc.sh     	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/sqlite.sh      	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/wt.sh          	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/yaml.sh        	|| exit 1
source ${arg0_realname%/*}/rmc-support/modules/yices.sh       	|| exit 1


########################################################################################################################
#                        ____  _          _ _ 
#                       / ___|| |__   ___| | |
#                       \___ \| '_ \ / _ \ | |
#                        ___) | | | |  __/ | |
#                       |____/|_| |_|\___|_|_|
#
########################################################################################################################

do_shell_help() {
    echo "usage: $arg0 [SWITCHES] [shell] SHELL_COMMAND..."
    echo "       $arg0 [SWITCHES]"
    echo "    Runs the shell command (or a shell) in an environment that's been set up for"
    echo "    building ROSE.  If the shell command's first word is something that this"
    echo "    script recognizes as a subcommand, then insert the word 'shell' before the"
    echo "    shell command."
}

do_shell() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_shell_help
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: $1" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done

    rmc_load_configuration

    # This is used by Robb's bash prompt. It adds the base name of the build directory to the prompt.
    export PS1_STACK="${RMC_ROSEBLD_ROOT##*/} $PS1_STACK"

    if [ "$#" -eq 0 ]; then
        exec $SHELL
    else
        exec "$@"
    fi
    echo "$arg0: exec failed:" "$@" >&2
    exit 1
}

########################################################################################################################
#                        ____                 _
#                       |  _ \ ___  ___  ___ | |_   _____
#                       | |_) / _ \/ __|/ _ \| \ \ / / _ \
#                       |  _ <  __/\__ \ (_) | |\ V /  __/
#                       |_| \_\___||___/\___/|_| \_/ \___|
#
########################################################################################################################

do_resolve_help() {
    echo "usage: $arg0 $COMMAND [--require] WHAT"
    echo "    This command prints environment variables without reading any config file. It can be used to query things"
    echo "    like directory names when building ROSE software dependencies. To use it, set the RMC_* environment variables"
    echo "    corresponding the 'rmc_*' lines that would normally be part of a configuration file. For instance, if you"
    echo "    need to find the boost installation directory given a boost version number and a compiler, you could do"
    echo "    something like this:"
    echo '        (eval $(RMC_BOOST_VERSION=1.60 '"$arg0"' resolve boost) && echo $RMC_BOOST_ROOT)'
    echo "    which might print"
    echo "        /home/matzke/GS-CAD/boost/1.60/gcc-4.8.4-default"
    echo "    since you didn't specify a compiler and 'g++' runs the C++ compiler from GCC-4.8.4 without any particular"
    echo "    language option. If you wanted a particular compiler you would set additional environment variables. This"
    echo "    command is most useful in shell scripts where running a subshell would be inconvenient."
    echo
    echo "    Another way to do almost the same thing is to have $arg0 invoke a bash command that prints the"
    echo "    environment. The difference is that invoking a shell command, as with most $arg0 commands, requires a"
    echo "    $CONFIG_BASE_NAME configuration file to be present. Here's how you could get a list of all the"
    echo "    relevant environment variables for a configured subshell:"
    echo "        $arg0 bash -c export |grep ' RMC_'"
}

do_resolve() {
    local require=
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_resolve_help
                exit 0
                ;;
            --require)
                require=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: $1" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$#" -ne 1 ]; then
        echo "$arg0 $COMMAND: incorrect usage; see --help" >&2
        exit 1
    fi
    local pkg="$1"
    if [ "$require" != "" ]; then
        eval 'rmc_'$pkg'_check'
    else
        eval 'rmc_'$pkg'_resolve'
    fi
    export |sed -n '/^declare -x RMC_[a-zA-Z_0-9]*=/ s/declare -x //p'
}

########################################################################################################################
#                         ____ _
#                        / ___| | ___  __ _ _ __
#                       | |   | |/ _ \/ _` | '__|
#                       | |___| |  __/ (_| | |
#                        \____|_|\___|\__,_|_|
#
########################################################################################################################

do_clear_help() {
    echo "usage: $arg0 $COMMAND"
    echo "    Emits shell code to erase all RMC environment variables. The output of this command should be"
    echo "    passed to the Bash 'eval' function or cut and pasted into a shell prompt. This command is intended"
    echo "    to be used in shell scripts to undo the effects of a previous '$arg0 resolve'; users will probably"
    echo "    not use this command since they're more apt to start a subshell instead, and exiting from that subshell"
    echo "    will automatically undo all the RMC environment variables."
}

do_clear() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_clear_help
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: '$1' (see $arg0 $COMMAND --help)" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$#" -ne 0 ]; then
        echo "$arg0 $COMMAND: incorrect usage (see $arg0 $COMMAND --help)" >&2
        exit 1
    fi
        
    local varnames=$(export |sed -n 's/^declare -x \(RMC_[a-zA-Z_0-9]\+\).*/\1/gp' |tr '\n' ' ')
    echo "unset $varnames";
}

########################################################################################################################
#                        ___       _ _
#                       |_ _|_ __ (_) |_
#                        | || '_ \| | __|
#                        | || | | | | |_
#                       |___|_| |_|_|\__|
#
########################################################################################################################

do_init_help() {
    echo "usage: $arg0 $COMMAND [SWITCHES] SOURCE_DIR"
    echo "    Initializes the current working directory so it can be used to compile ROSE. If a configuration file,"
    echo "    $CONFIG_BASE_NAME, already exists in the current working directory then this command refuses to run unless"
    echo "    the '--force' flag is also given. The $CONFIG_BASE_NAME file is created in the CWD by copying it from"
    echo "    ~/.rmc-defaults.cfg or by creating it from scratch and then invoking the user's editor on the file. When"
    echo "    it's created from scratch the settings are only guesses -- they'll need to be edited to reflect the software"
    echo "    that's actually installed."
    echo
    echo "  Switches:"
    echo "      --force | -f"
    echo "          Force creation of a new configuration even though this build directory seems to already be initialized."
    echo "      --instructions"
    echo "      --no-instructions | -s"
    echo "          When creating a new configuration file, either include comments about what each line does and how to"
    echo "          use it, or create a mostly comment-free file."
}

do_init() {

    # Parse command-line
    local force= show_instructions=yes
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_init_help
                exit 0
                ;;
            --force|-f)
                force=yes
                shift
                ;;
            --instructions)
                show_instructions=yes
                shift
                ;;
            --no-instructions|-s)
                show_instructions=
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: '$1' (see $arg0 $COMMAND --help)" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$#" -ne 1 ]; then
        do_init_help >&2
        exit 1
    fi

    # Check the source directory
    local srcdir="$1"
    if [ ! -d "$srcdir" ]; then
        echo "$arg0 $COMMAND: source directory does not exist: $srcdir" >&2
        exit 1
    fi
    if [ ! -e "$srcdir/src/frontend/BinaryLoader/BinaryLoader.h" ]; then
        echo "$arg0 $COMMAND: directory does not appear to be top of ROSE source code: $srcdir" >&2
        exit 1
    fi
    srcdir=$(rmc_realpath "$srcdir")

    # Create and edit the config file
    if [ -e "$CONFIG_BASE_NAME" -a "$force" = "" ]; then
        echo "$arg0 init: CWD appears to be set up already; use '--force' to override" >&2
        exit 1
    fi
    if [ -e "$HOME/.rmc-defaults.cfg" ]; then
        cp "$HOME/.rmc-defaults.cfg" "$CONFIG_BASE_NAME" || exit 1
    else
        (
            echo "# ROSE meta config                  -*- shell-script -*-"
            echo
            echo "# Source code is found here:"
            echo "rmc_rosesrc $srcdir"
            echo
            echo "#----------------------------------"
            echo "#         General stuff"
            echo "#----------------------------------"
            echo

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Location of software dependencies. ROSE can use system-installed"
                echo "# dependencies, or locally installed dependencies. Locally installed"
                echo "# dependencies should follow a specific naming scheme known to RMC"
                echo "# so that the user can specify a dependency by just a version number."
            fi
            echo "rmc_toolchain    $HOME/GS-CAD"

            if [ "$show_instructions" != "" ]; then
                echo "# Build system is either 'cmake' or 'autoconf'"
            fi
            echo "rmc_build        autoconf"

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Installation prefix for 'make install'. The argument is"
                echo "#   absolute path   -- install into the specified path"
                echo "#   relative path   -- installation prefix w.r.t. build directory"
                echo "#   'yes' (default) -- build-relative directory named 'installed'"
                echo "#   'no'            -- installation is not supported"
            fi
            echo "rmc_install      yes"

            if  [ "$show_instructions" != "" ]; then
                echo
                echo "# Maximum parallelism for things like 'make' commands."
                echo "#   positive number -- limit parallelism to specified value"
                echo "#   'system' (dflt) -- use number of compute cores as the limit"
                echo "#   'unlimited'     -- no hard limit on parallelism"
            fi
            echo "rmc_parallelism  system"

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Language frontends. The argument should be a comma-separated list"
                echo "# of language names with no intervening white space.  Possible languages"
                echo "# are 'all', 'non', 'binaries', 'c', 'c++', 'cuda', 'fortran', 'java'"
                echo "# 'x10', 'opencl', 'php', 'matlab', and 'python'."
            fi
            echo "rmc_languages    all"

            echo
            echo
            echo "#----------------------------------"
            echo "#         Compiling"
            echo "#----------------------------------"
            echo

            if [ "$show_instructions" != "" ]; then
                echo "# Comand that runs the C++ compiler.  Relative names are searched"
                echo "# according to the \$PATH environment variable."
            fi
            echo "rmc_compiler     g++"

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Whether ('yes' or 'no') to generate symbol tables useful for debugging"
                echo "# with tools like GDB. The default is 'yes'. Debugging support and"
                echo "# optimization are orthogonal issues."
            fi
            echo "rmc_debug        yes"

            if  [ "$show_instructions" != "" ]; then
                echo
                echo "# Whether ('yes' or 'no') to add optimization switches to compiler"
                echo "# commands. If 'no' then optimizations are explicitly turned off, which"
                echo "# can be useful for debugging since C++ statements will generally have"
                echo "# the same order as the binary instructions."
            fi
            echo "rmc_optimize     yes"

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Whether ('yes' or 'no') to cause the C++ compiler to emit warnings"
                echo "# about questionable source code."
            fi
            echo "rmc_warnings     yes"

	    if [ "$show_instructions" != "" ]; then
		echo
		echo "# Whether to generate code-coverage results. When code coverage is"
		echo "# enabled, the compiler is adjusted so it instruments programs, and"
		echo "# running said programs will produce output which can be analyzed by"
		echo "# tools like gcov and lcov.  The value should be 'yes' or 'no'."
	    fi
	    echo "rmc_code_coverage no"

            if [ "$show_instructions" != "" ]; then
                echo
                echo "# Behavior of Sawyer ASSERT_... macros."
                echo "#   'abort' (dflt)-- message emitted, then abort process"
                echo "#   'exit'        -- message emitted, then exit with non-zero status"
                echo "#   'throw'       -- exception thrown, which contains the message"
            fi
            echo "rmc_assertions   abort"

            echo
            echo
            echo "#----------------------------------"
            echo "#         Additional software"
            echo "#----------------------------------"
            echo

            if [ "$show_instructions" != "" ]; then
                echo "# These directives all take the same kinds of arguments:"
                echo "#   'none'        -- ROSE should not look for or use this dependency"
                echo "#   'system'      -- Use the publicly installed version; a.k.a. 'yes'"
                echo "#   'ambivalent'  -- Do not specify anthing in the ROSE configure command"
                echo "#   directory     -- Look in the directory for includes and libs"
                echo "#   file          -- Use the specified file (not for libraries)"
                echo "#   vesion        -- Look for a particular version"
                echo "#   version base  -- Same, but use specified base directory"
                echo "# If a version is specified without a base directory then this"
                echo "# script searches certain well-known locations. Versioned software"
                echo "# directories follow a specific naming scheme which incorporates"
                echo "# information about their dependencies, therefore specifying software"
                echo "# by version number is the safest way to make sure all software is"
                echo "# configured consistently."
                echo
            fi
            echo "rmc_boost        1.50"
            echo "rmc_cmake        system"
            echo "rmc_dlib         18.17"
            echo "rmc_doxygen      ambivalent"
            echo "rmc_edg          4.9"
            echo "rmc_magic        system"
            echo "rmc_python       /usr/bin/python3"
            echo "rmc_qt           none"
            echo "rmc_readline     system"
            echo "rmc_sqlite       system"
            echo "rmc_wt           3.3.4"
            echo "rmc_yaml         0.5.1"
            echo "rmc_yices        1.0.34"
        ) >"$CONFIG_BASE_NAME"
    fi
    ${EDITOR-vi} "$CONFIG_BASE_NAME"
    do_shell true || exit 1
}

########################################################################################################################
#                         ____             __ _
#                        / ___|___  _ __  / _(_) __ _
#                       | |   / _ \| '_ \| |_| |/ _` |
#                       | |__| (_) | | | |  _| | (_| |
#                        \____\___/|_| |_|_| |_|\__, |
#                                               |___/
#
########################################################################################################################

do_config_help() {
    echo "usage: $arg0 [--dry-run] $COMMAND"
    echo "    Runs (or shows) the ROSE configuration command. If the build system (RMC_BUILD_SYSTEM) is set to 'cmake'"
    echo "    then a 'cmake' command is used; if the build system is 'autoconf' then a 'configure' command is used. The"
    echo "    --dry-run switch prints the command rather than executing it."
}

# Subcommand to configure the build directory (autoconf, cmake, etc)
#
#   config [--dry-run]
#      Runs the cmake or autoconf commands in order to build the
#      ROSE makefiles and populate the subdirectories in the build
#      tree.
#

do_config() {
    local cmd dry_run
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_config_help
                exit 0
                ;;
            --dry-run)
                dry_run="--dry-run"
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: '$1'" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    rmc_load_configuration

    case "$RMC_BUILD_SYSTEM" in
        autoconf)
            rmc_autoconf_run $dry_run
            ;;
        cmake)
            rmc_cmake_run $dry_run
            ;;

        *)
            echo "$arg0 $COMMAND: unknown build system: $RMC_BUILD_SYSTEM'" >&2
            exit 1
            ;;
    esac
}

########################################################################################################################
#                        __  __       _
#                       |  \/  | __ _| | _____
#                       | |\/| |/ _` | |/ / _ \
#                       | |  | | (_| |   <  __/
#                       |_|  |_|\__,_|_|\_\___|
#
########################################################################################################################

do_make_help() {
    echo "usage: $arg0 $COMMAND[-WHAT] [SWITCHES] [TARGETS...]"
    echo "    Runs an extended version of 'make' (if you want the normal 'make' then either run it in an interactive"
    echo "    subshell or use '$arg0 shell make ...').  The extended version differs from the normal 'make' command in"
    echo "    a few ways:"
    echo "        * The command can be 'make-binary', 'make-source', 'make-here', or 'make-lib' which run 'make' in"
    echo "          various ROSE build subdirectories. For instance, 'make-binary' will build the library, binary analysis"
    echo "          test directories, and certain binary analysis projects.  These are meant only a conveniences; the"
    echo "          user could just as well specify the directories manually."
    echo "        * The --dry-run switch is intercepted by $arg0 and prints the commands that would be executed. This"
    echo "          is a good way to see what 'make-binary' etc. actually do."
    echo "        * The '--jobs=N' switch is automatically added based on the parallelism specified in the config file"
    echo "          or detected automatically. If a --jobs or -j switch is specified by the user then the user's choice"
    echo "          takes precedence."
    echo "        * The '--silent' switch is automatically added (unless the user says '--no-silent'), which causes"
    echo "          GNU make to not be so verbose.  This is nice for interactive use, but if you want to see the"
    echo "          commands flying by use '--no-silent' and 'V=1 VERBOSE=1'."
    echo "        * Multiple targets can be specified and they're run sequentially. This is different than plain 'make'"
    echo "          which builds the targets concurrently if --jobs is greater than one, and is useful for targets that"
    echo "          don't produce artifacts. For instance, you can say '$arg0 make clean all' to first clean the"
    echo "          build tree and then rebuild the artifacts (plain make might try to do these in parallel, which is"
    echo "          nonsense)."
    echo "    If multiple directories and multiple targets are both specified then a nested loop is used with the outer"
    echo "    loop processing directories and the inner loop processing the targets.  Use '--dry-run' to see what happens."
}

do_make() {
    local where="$1"; shift

    # Parse "make" switches, keeping track of a couple special ones.
    local make_switches=()
    local have_C have_j dry_run have_silent=--silent
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_make_help
                exit 0
                ;;
            --dry-run)
                # Steal this for ourselves. Users can still run "make"
                # the normal way if they really want --dry-run to be
                # for the "make" command.
                dry_run="--dry-run"
                shift
                ;;
            -C|--directory)
                make_switches=("${make_swithces[@]}" "$1" "$2")
                have_C="$1 $2"
                shift; shift
                ;;
            --directory=*)
                make_switches=("${make_switches[@]}" "$1")
                have_C="$1"
                shift
                ;;
            -j|--jobs)
                case "$2" in
                    [0-9]*[0-9])
                        have_j="$1 $2"
                        shift; shift
                        ;;
                    *)
                        have_j="$1"
                        shift
                        ;;
                esac
                ;;
            -j*)
                have_j="$1"
                shift
                ;;
            --jobs=*)
                have_j="$1"
                shift
                ;;
            --silent)
                have_silent=--silent
                shift
                ;;
            --no-silent)
                have_silent=
                shift
                ;;
            --debug|-f|--file|--makefile|-I|--include-dir|-l|--load-average|-o|--old-file|--assume-old|-O|--output-sync|-W|--what-if|--new-file|--assume-new)
                # These all take an argument
                make_switches=("${make_swithces[@]}" "$1" "$2")
                shift; shift
                ;;
            -*)
                # These take no arguments
                make_switches=("${make_switches[@]}" "$1")
                shift
                ;;
            *=*)
                # These are make variables, not targets
                make_switches=("${make_switches[@]}" "$1")
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    local targets=("$@")
    if [ "${#targets[*]}" -eq 0 ]; then
        targets=(all)
    fi

    # Choose the directories were we'll run "make"
    rmc_load_configuration
    local dirs=()
    case "$where" in
        binary)
            dirs=("-C $RMC_ROSEBLD_ROOT/src"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/binaryTests"
                  "-C $RMC_ROSEBLD_ROOT/projects/BinaryAnalysisTools"
                  "-C $RMC_ROSEBLD_ROOT/projects/simulator2"
                  "-C $RMC_ROSEBLD_ROOT/projects/BinaryCloneDetection"
            )
            ;;
        source)
            dirs=("-C $RMC_ROSEBLD_ROOT/src"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/PHPTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/ROSETTA"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/abstractMemoryObjectTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astFileIOTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astInliningTests"

                  # 2015-12-07
                  # rose_inputbuildVariableDeclaration.C fails
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/astInterfaceTests"

                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astLValueTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astMergeTests"

                  # 2015-12-07
                  # seq7a_test2001_01.C fails: for a function-style cast, remove the redundant "::A"
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/astOutliningTests"

                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astPerformanceTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astProcessingTests"

                  # 2015-12-07
                  # testQuery3_input1.C fails: assert numberOfStatementsInSimple == numberOfStatements
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/astQueryTestsTests"

                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astRewriteTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astSnippetTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astSymbolTableTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/astTokenStreamTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/binaryTests"

                  # 2015-12-07
                  # fileLocation_test2001_01.C fails: cannot call constructor A::A directly
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/fileLocation_tests"

                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/graph_tests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/loopProcessingTests"
                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/mergeTraversal_tests"

                  # 2015-12-07
                  # array-one.o: fails: segfault in Java runtime
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/ompLoweringTests"

                  # 2015-12-07
                  # test02-10 fails: "You didn't heed the BIG FAT WARNING from above!"
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/programAnalysisTests"

                  # 2015-12-07
                  # test2001_01.C fails: for a function-style cast, remove the redundant "::A"
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/programTransformationTests"

                  "-C $RMC_ROSEBLD_ROOT/tests/roseTests/roseHPCToolkitTests"

                  # 2015-12-07
                  # testQuery3_input.C: assert numberOfStatementsInSimple == numberOfStatements
                  #"-C $RMC_ROSEBLD_ROOT/tests/roseTests/utilTests"
            )
            ;;
                  
                  
        here)
            dirs=("")
            have_C=
            ;;
        lib)
            dirs=("-C $RMC_ROSEBLD_ROOT/src")
            ;;
        *)
            echo "$arg0 $COMMAND: unknown location: '$where'" >&2
            exit 1
            ;;
    esac
    if [ "$have_C" != "" ]; then
        echo "$arg0 $COMMAND: '$have_C' is incompatible with this command" >&2
        exit 1
    fi

    # Figure out the parallelism.  The "-j" etc. switches will override
    # the values from our own configuration files.
    local parallelism
    if [ "$have_j" != "" ]; then
        parallelism="$have_j"
    elif [ "$RMC_PARALLELISM" = "unlimited" ]; then
        parallelism="-j"
    else
        parallelism="-j$RMC_PARALLELISM"
    fi

    # Run "make" in each directory for each target.
    for target in "${targets[@]}"; do
        for dir in "${dirs[@]}"; do
            # Use --silent because ROSE's autoconf- and cmake-generated
            # maekfiles generally print their own output anyway. Otherwise
            # "make" is so noisy that warning messages tend to get overlooked
            rmc_execute $dry_run make $parallelism $have_silent "$dir" "${make_switches[@]}" "$target" \
                || exit 1
        done
    done
    return 0
}

########################################################################################################################
#                        _     _     _   
#                       | |   (_)___| |_ 
#                       | |   | / __| __|
#                       | |___| \__ \ |_ 
#                       |_____|_|___/\__|
#                 
########################################################################################################################

do_list_help() {
    echo "usage: $arg0 $COMMAND [SWITCHES] DEPENDENCY"
    echo "    Lists installed versions of some dependency, such as 'boost'.  The switches are:"
    echo "        --help | -h"
    echo "            Show this documentation."
    echo "        --format=human|shell"
    echo "            Show the results in a human readable format or as shell commands to set RMC variables. The human"
    echo "            format is the same as the shell format except it shows only the values of the shell variables and"
    echo "            separates them by tab characters for better alignment."
    echo "        --terse"
    echo "            Show only the primary version number. For instance, Wt is normally listed as a triplet containing"
    echo "            the Wt version number, the boost version number, and the C++ compiler name, but this switch would"
    echo "            cause only the Wt version number to be shown. Terse human format shows the version number space-"
    echo "            separated on a single line."
}

do_list() {
    local format=human terse=
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_list_help
                exit 1
                ;;
            --format=human|--format=shell)
                format="${1#--format=}"
                shift
                ;;
            --terse)
                terse=yes
                shift
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: $1" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done

    local dependency="$1"; shift
    if [ "$dependency" = "" ]; then
        echo "$arg0 $COMMAND: incorrect usage; see '$arg0 $COMMAND --help' for details" >&2
        exit 1
    fi

    if [ "$terse" != "" ]; then
        case "$format" in
            shell)
                rmc_list "$dependency" shell |cut -d' ' -f1 |sort |uniq
                ;;
            human)
                local versions=$(rmc_list "$dependency" human |cut       -f1 |sort |uniq)
                echo $versions
                ;;
        esac
    else
        rmc_list "$dependency" "$format"
    fi
}

            
########################################################################################################################
#                        ____            _             _   _
#                       |  _ \ ___  __ _| |_ __   __ _| |_| |__
#                       | |_) / _ \/ _` | | '_ \ / _` | __| '_ \
#                       |  _ <  __/ (_| | | |_) | (_| | |_| | | |
#                       |_| \_\___|\__,_|_| .__/ \__,_|\__|_| |_|
#                                         |_|
#
########################################################################################################################

do_realpath_help() {
    echo "usage: $arg0 $COMMAND PATH"
    echo "    Resolves PATH to a canonical name by recursively expanding symbolic links and replacing '.' and '..'."
    echo "    This functionality is exposed as a command because 'realpath' is often not installed on the system"
    echo "    and we don't want to depend on having things like Python or Perl installed to do this."
}

do_realpath() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --help|-h)
                do_realpath_help
                exit 1
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: $1" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$#" -ne 1 ]; then
        echo "usage: $arg0 $COMMAND PATH" >&2
        exit 1
    fi
    rmc_realpath "$1"
}

########################################################################################################################
#                        __  __       _
#                       |  \/  | __ _(_)_ __
#                       | |\/| |/ _` | | '_ \
#                       | |  | | (_| | | | | |
#                       |_|  |_|\__,_|_|_| |_|
#
########################################################################################################################

help=
directory=
while [ "$#" -gt 0 ]; do
    case "$1" in
        -C)
            directory="$2"
            shift; shift
            ;;
        help|--help|-h)
            help=--help
            shift
            ;;
        --version|-V)
            echo "$arg0-$RMC_RMC_VERSION"
            exit 0
            ;;
        -*)
            echo "$arg0: unknown global switch: '$1'" >&2
            exit 1
            ;;
        *)
            COMMAND="$1"
            shift
            break
            ;;
    esac
done

if [ "$directory" != "" ]; then
    cd "$directory" || exit 1
fi

case "$COMMAND" in
    init)
        do_init $help "$@"
        ;;
    clear)
        do_clear $help "$@"
        ;;
    config)
        do_config $help "$@"
        ;;
    list)
        do_list $help "$@"
        ;;
    make)
        do_make "here" $help "$@"
        ;;
    make-*)
        do_make "${COMMAND#make-}" $help "$@"
        ;;
    shell)
        do_shell $help "$@"
        ;;
    resolve)
        do_resolve $help "$@"
        ;;
    realpath)
        do_realpath $help "$@"
        ;;
    "")
        if [ "$help" != "" ]; then
            rmc_help
        else
            do_shell
        fi
        ;;
    *)
        do_shell $help "$COMMAND" "$@"
        ;;
esac
