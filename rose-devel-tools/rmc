#!/bin/bash

# ROSE meta configuration.
#
# usage: $0 [global_switches] command [cmd_switches] [args]
#
# Global switches:
#
# Commands are:
#   init [--force] BUILD_DIR SRC_DIR
#      Initializes the build tree.  This creates a new build
#      directory (which must not exist prior to this command) and
#      initializes the rmc config file, then fires up the user's
#      editor on this file so he can make adjustments, then starts
#      a shell in the build directory.
#
#   config [--dry-run]
#      Runs the cmake or autoconf commands in order to build the
#      ROSE makefiles and populate the subdirectories in the build
#      tree.
#
#   make[-WHAT] [SWITCHES] [TARGETS]
#      Runs "make" for each of the TARGETS sequentially in directories
#      specific to WHAT (or the CWD). For instance, saying "build-binary
#      clean all" runs "make clean" in all directories associated with
#      "binary", and then runs "make all" in those same directories.  The
#      same make switches are passed to each invocation of make (e.g., "-k").
#
#   [shell] command
#      Runs a shell command. The word "shell" is optional if the
#      shell command doesn't conflict with any of the other subcommands.
#      If you say just "shell" (or even nothing) then you'll get a subshell.

arg0="${0##*/}"

COMMAND=

############################################################################
#                          Functions
############################################################################

# Find the top of the build directory.  The top is the CWD or its closest
# ancestor that has a ".rmc-main.cfg" configuration file.
top_blddir() {
    local dir=$(pwd)
    while true; do
        if [ -e "$dir/.rmc-main.cfg" ]; then
            echo "$dir"
            return 0;
        fi
        if [ "$dir" = "/" ]; then
            return 1
        fi
        dir=$(realpath "$dir/..")
    done
}

# Check whether $1 looks like a version number.
is_version_string() {
    perl -e 'exit(0 == $ARGV[0] =~ /^\d+(\.\d+)+$/)' "$1"
}

# Sets variables based on arguments. The variables are:
#   RMC_*_VERSION
#   RMC_*_BASEDIR
#   RMC_*_ROOT
parse_version_or() {
    local or_else="$1" # directory|file
    local caller="$2"
    local pkg="$3"
    local arg1="$4"
    local arg2="$5"

    if [ "$arg1" = "no" ]; then
        eval 'RMC_'$pkg'_VERSION='
        eval 'RMC_'$pkg'_BASEDIR='
        eval 'RMC_'$pkg'_ROOT='
    elif [ "$arg1" = "system" -o "$arg1" = "yes" ]; then
        eval 'RMC_'$pkg'_VERSION=system'
        eval 'RMC_'$pkg'_BASEDIR='
        eval 'RMC_'$pkg'_ROOT='
    elif is_version_string "$arg1"; then
        eval 'RMC_'$pkg'_VERSION="$arg1"'
        eval 'RMC_'$pkg'_BASEDIR="$arg2"'
        eval 'RMC_'$pkg'_ROOT='
    elif [ "$arg2" != "" ]; then
        echo "$caller: not a version number: '$arg1'" >&2
        exit 1
    elif [ "$or_else" = "directory" -a ! -d "$arg1" ]; then
        echo "$caller: invalid directory: $arg1" >&2
        exit 1
    elif [ "$or_else" = "file" -a ! -r "$arg1" ]; then
        echo "$caller: no such file: $arg1" >&2
        exit 1
    else
        eval 'RMC_'$pkg'_VERSION='
        eval 'RMC_'$pkg'_BASEDIR='
        eval 'RMC_'$pkg'_ROOT="$arg1"'
    fi
}

# These functions return a version number given an installation root.
version_boost() {
    local root="$1"
    local hdr="$root/include/boost/version.hpp"
    perl -ne '/BOOST_LIB_VERSION\s+"([_0-9]+)"/ && print $1' "$hdr" |tr _ .
}
version_dlib() {
    local root="$1"
    local hdr="$root/dlib/revision.h"
    local major=$(perl -ne '/DLIB_MAJOR_VERSION\s+(\d+)/ && print $1' "$hdr")
    local minor=$(perl -ne '/DLIB_MINOR_VERSION\s+(\d+)/ && print $1' "$hdr")
    echo "$major.$minor"
}
version_python() {
    local python="$1"
    local output=$("$python" --version 2>&1 |head -n1)
    perl -e '$ARGV[0] =~ /(\d+(\.\d+)+)/ && print $1' "$output"
}
version_readline() {
    local root="$1"
    local hdr="$root/include/readline/readline.h"
    local major=$(perl -ne '/RL_VERSION_MAJOR\s+(\d+)/ && print $1' "$hdr")
    local minor=$(perl -ne '/RL_VERSION_MINOR\s+(\d+)/ && print $1' "$hdr")
    echo "$major.$minor"
}
version_wt() {
    local root="$1"
    local hdr="$root/include/Wt/WConfig.h"
    perl -ne '/WT_VERSION_STR\s+"(\d+(\.\d+)+)"/ && print $1' "$hdr"
}
version_yaml() {
    local root="$1"
    perl -e '$ARGV[0] =~ /\byaml.*?(\d+(\.\d+)+)/ && print $1' "$root"
}
version_doxygen() {
    local doxygen="$1"
    local output=$("$doxygen" --version 2>&1 |head -n1)
    perl -e '$ARGV[0] =~ /(\d+(\.\d+)+)/ && print $1' "$output"
}
version_cmake() {
    local cmake="$1"
    local output=$("$cmake" --version 2>&1 |head -n1)
    perl -e '$ARGV[0] =~ /(\d+(\.\d+)+)/ && print $1' "$output"
}

# Find version number for a package.  The package has an upper-case name which
# we use to find the root of its installation tree, and a printable name that
# shows up in error messages.  If the package alread has a version number then
# we check that the detected version number matches.
find_version() {
    local pkg="$1" name="$2"
    local pkglc=$(echo "$pkg" |tr A-Z a-z)
    [ "$name" = "" ] && name="$pkglc"
    local root=$(eval echo '$RMC_'$pkg'_ROOT')
    local vers=$(eval echo '$RMC_'$pkg'_VERSION')
    local v=$(eval 'version_'$pkglc' "$root"')
    if [ "$v" = "" ]; then
        echo "$arg0: cannot determine $name version number for $root" >&2
        exit 1
    fi
    if [ "$vers" != "" -a "$vers" != "$v" ]; then
        echo "$arg0: $name version mismatch: found '$v', requested '$vers'" >&2
        exit 1
    fi
    eval 'RMC_'$pkg'_VERSION="$v"'
}

# These functions return the installation root when given a base and version
root_boost() {
    local base="$1" vers="$2"
    echo "$base/$vers/$RMC_CXX_BASENAME-$RMC_CXX_VERSION"
}
root_dlib() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}
root_magic() {
    echo "$arg0: magic library cannot be specified by version number" >&2
    exit 1
}
root_readline() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}
root_wt() {
    local base="$1" vers="$2"
    echo "$base/$vers/boost-$RMC_BOOST_VERSION/$RMC_CXX_BASENAME-$RMC_CXX_VERSION"
}
root_yaml() {
    local base="$1" vers="$2"
    echo "$base/$vers/boost-$RMC_BOOST_VERSION/$RMC_CXX_BASENAME-$RMC_CXX_VERSION"
}
root_yices() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}
root_python() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}
root_doxygen() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}
root_cmake() {
    local base="$1" vers="$2"
    echo "$base/$vers"
}

# Find the root directory for a package when given its version number.
find_root() {
    local pkg="$1" name="$2"
    local pkglc=$(echo "$pkg" |tr A-Z a-z)
    [ "$name" = "" ] && name="$pkglc"
    local base=$(eval echo '$RMC_'$pkg'_BASEDIR')
    local vers=$(eval echo '$RMC_'$pkg'_VERSION')

    if [ "$vers" = "system" ]; then
        eval 'RMC_'$pkg'_ROOT=system'
        return 0
    fi

    if [ "$base" = "" ]; then
        for f in "$HOME/GS-CAD" "$HOME" "/usr/local"; do
            if [ -d "$f/$pkglc" ]; then
                base="$f/$pkglc"
                break
            fi
        done
        if [ "$base" = "" ]; then
            echo "$arg0: cannot find $name installation base" >&2
            exit 1
        fi
    fi

    local root=$(eval 'root_'$pkglc' "$base" "$vers"')
    if [ ! -d "$root" ]; then
        echo "$arg0: invalid $name root directory: $root" >&2
        exit 1
    fi

    eval 'RMC_'$pkg'_ROOT=$(realpath "$root")'
}

load_configuration() {
    resolve_build_dir
    local config="$RMC_BUILD_DIR/.rmc-main.cfg"
    if [ ! -r "$config" ]; then
        echo "$arg0: build directory is not initialized" >&2
        exit 1
    fi
    source "$config" || exit 1
    resolve
}

# Find the prefix directory (or file if $subname isn't empty) for a package.
find_prefix() {
    local pkg"=$1" name="$2" subname="$3"
    [ "$name" = "" ] && name=$(echo "$pkg" |tr A-Z a-z)
    local root=$(eval echo '$RMC_'$pkg'_ROOT')
    case "$root" in
	system)
	    echo "$name"
	    ;;
	""|no)
	    ;;
	*)
	    if [ "$subname" = "" ]; then
		echo "$root"
	    elif [ -e "$root/$subname" ]; then
		echo "$root/$subname"
	    elif [ -e "$root" -a ! -d "$root" ]; then
		echo "$root"
	    else
		echo "$arg0: no file found for $name: $root/$subname" >&2
		echo "NOT_FOUND"
	    fi
            ;;
    esac
}

# Generate an optional autotools "--with-..." argument for a package.
configure_with() {
    local pkg="$1" name="$2" subname="$3"
    [ "$name" = "" ] && name=$(echo "$pkg" |tr A-Z a-z)
    local root=$(eval echo '$RMC_'$pkg'_ROOT')
    case "$root" in
        system)
            echo "--with-$name"
            ;;
        ""|no)
	    echo "--without-$name"
            ;;
        *)
	    echo "--with-$name=$(find_prefix "$pkg" "$name" "$subname")"
            ;;
    esac
}

# Generate optional cmake "-D..._ROOT=..." argument for a package.
cmake_Droot() {
    local pkg="$1" name="$2" subname="$3"
    [ "$name" = "" ] && name=$(echo "$pkg" |tr A-Z a-z)
    local root=$(eval echo '$RMC_'$pkg'_ROOT')
    case "$root" in
        system|""|no)
            ;;
        *)
	    echo "-D${pkg}_ROOT=$(find_prefix "$pkg" "$name" "$subname")"
            ;;
    esac
}

add_library_path() {
    local pkg="$1" path="$2"
    local root=$(eval echo '$RMC_'$pkg'_ROOT')
    [ "$root" = "system" -o "$root" = "" ] && return 0
    local full="$root/$path"
    if [ ! -d "$full" ]; then
        echo "$arg0: library path does not exist: $full" >&2
        exit 1
    fi
    full=$(realpath "$full")
    for f in /lib /usr/lib /usr/local/lib; do
        if [ "$full" = $(realpath "$f") ]; then
            return 0
        fi
    done
    eval $(path-adjust --var=LD_LIBRARY_PATH --prepend --move insert "$full")
    
}

execute() {
    local dry_run
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --dry-run)
                dry_run=yes
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    if [ "$dry_run" = "yes" ]; then
        echo "+" "$@" >&2
    else
        eval "$@"
    fi
}

############################################################################
# Configuration commands. These just set up variables that are resolved
# later. This allows the configuration commands to appear in any order in
# the configuration file.
############################################################################

# These are set automatically
export RMC_BUILD_DIR=
export RMC_SOURCE_DIR=
export LD_LIBRARY_PATH

# Installation prefix.
#
# usage: rmc_install yes|no|DIRECTORY
#
# If DIRECTORY is relative then it will be relative to the top of the build
# directory.  A value of "no" means "make install" will probably fail. A
# value of yes just uses the default.
export RMC_PREFIX=installed
rmc_install() {
    if [ "$1" = "" -o "$1" = "yes" ]; then
        RMC_PREFIX=installed
    else
        RMC_PREFIX="$1"
    fi
}

# Build system
#
# usage: rmc_build_system autoconf|cmake
#
export RMC_BUILD_SYSTEM=autoconf
rmc_build_system() {
    local arg="$1"
    case "$arg" in
        autoconf|cmake)
            RMC_BUILD_SYSTEM="$arg"
            ;;
        *)
            echo "rmc_build_system: argument should be 'autoconf' or 'cmake'" >&2
            ;;
    esac
}

# Parallelism limit
#
# usage: rmc_parallelism N|system|unlimited
#
# where "N" means limit parallelism to N procs (as in "make -jN")
#       "system" limit to the number of CPU cores present on this machine
#       "unlimited" means no limit (as in "make -j" without a number)
#
export RMC_PARALLELISM=system
rmc_parallelism() {
    local arg="$1"
    case "$arg" in
        system|unlimited)
            RMC_PARALLELISM="$arg"
            ;;
        [0-9]*[0-9])
            RMC_PARALLELISM="$arg"
            ;;
        *)
            echo "rmc_parallelism: invalid argument: '$arg'" >&2
            exit 1
            ;;
    esac
}

# What frontend languages to support
#
# usage: rmc_languages all|COMMA_SEPARATED_LIST
#
export RMC_LANGUAGES=all
rmc_languages() {
    RMC_LANGUAGES="$1"
}

# Debugging support
#
# usage: rmc_debug yes|no
#
export RMC_DEBUG=yes
rmc_debug() {
    local arg="$1"
    case "$arg" in
        ""|yes)
            RMC_DEBUG=yes
            ;;
        no)
            RMC_DEBUG=no
            ;;
        *)
            echo "rmc_debug: invalid setting: '$arg'" >&2
            exit 1
            ;;
    esac
}

# Compiler warnings. Turn on compiler warnings.
#
# usage: rmc_warnings yes|no
#
export RMC_WARN=yes
rmc_warnings() {
    local arg="$1"
    case "$arg" in
        ""|yes)
            RMC_WARN=yes
            ;;
        no)
            RMC_WARN=no
            ;;
        *)
            echo "rmc_warnings: invalid setting: '$arg'" >&2
            exit 1
            ;;
    esac
}

# Optimization
#
# usage: rmc_optimize yes|no
#
export RMC_OPTIM=yes
rmc_optimize() {
    local arg="$1"
    case "$arg" in
        ""|yes)
            RMC_OPTIM=yes
            ;;
        no)
            RMC_OPTIM=no
            ;;
        *)
            echo "rmc_optimize: invalid setting: '$arg'" >&2
            exit 1
            ;;
    esac
}

# Failure mode for assertions (Sawyer ASSERT_* macros)
#
# usage: rmc_assertions abort|exit|throw
#
export RMC_ASSERTIONS=abort
rmc_assertions() {
    local arg="$1"
    case "$arg" in
        abort|exit|throw)
            RMC_ASSERTIONS="$arg"
            ;;
        *)
            echo "rmc_assertions: method must be 'abort', 'exit', or 'throw'" >&2
            exit 1
            ;;
    esac
}

# C++ compiler
#
# usage: rmc_compiler NAME
#        rmc_compiler VERSION
#
export RMC_CXX=g++
export RMC_CXX_VERSION=
export RMC_CXX_BASENAME=
rmc_compiler() {
    local cxx="$1"
    if [ "$cxx" = "" ]; then
        echo "rmc_compiler: no compiler specified" >&2
        exit 1
    fi

    # Does the name look like a version number?
    local version=$(perl -e '$ARGV[0] =~ /^(\d+(\.\d+)+)$/ and print "$1"' "$cxx")
    if [ "$version" != "" ]; then
	RMC_CXX_VERSION="$version"
    else
	RMC_CXX="$cxx"
    fi
}

# Extensive checking (affects "check" command)
#
# usage: rmc_checks LIST
#
# LIST of things that the "check" should test. Possible items in the list:
#   library  -- run "make check" in the $RMC_BUILD_DIR/tests directory
#   binary   -- run "make check" in various binary analysis directories
#   projects -- run "make check" in the top-level projects directory
#   all      -- run all possible checks (i.e., "make check" in top build dir)
#
# You can always run plain old "make check" wherever you like too.
#
export RMC_CHECKS=
rmc_checks() {
    if [ "$#" -eq 0 ]; then
        RMC_CHECKS="library"
    else
        for type in "$@"; do
            case "$type" in
                library|binary|projects|all)
                    if [ "$RMC_CHECKS" = "" ]; then
                        RMC_CHECKS="$type"
                    else
                        RMC_CHECKS="$RMC_CHECKS:$type"
                    fi
                    ;;
                *)
                    echo "rmc_checks: invalid check type: '$type'" >&2
                    exit 1
                    ;;
            esac
        done
    fi
}

# Boost installation directory
#
# usage: rmc_boost VERSION [BASE]
#    or: rmc_boost DIRECTORY
#
export RMC_BOOST_BASEDIR=
export RMC_BOOST_VERSION=
export RMC_BOOST_ROOT=
rmc_boost() {
    parse_version_or directory rmc_boost BOOST "$@"
}

# Wt web toolkit
#
# usage: rmc_web_toolkit VERSION [BASE]
#    or: rmc_web_toolkit DIRECTORY
#    or: rmc_web_toolkit no
#
export RMC_WT_BASEDIR=
export RMC_WT_VERSION=
export RMC_WT_ROOT=
rmc_web_toolkit() {
    parse_version_or directory rmc_web_toolkit WT "$@"
}

# libmagic for identifying magic numbers
#
# usage: rmc_magic VERSION [BASE]
#    or: rmc_magic DIRECTORY
#    or: rmc_magic system  (or "yes")
#    or: rmc_magic no
#
export RMC_MAGIC_BASEDIR=
export RMC_MAGIC_VERSION=
export RMC_MAGIC_ROOT=
rmc_magic() {
    parse_version_or directory rmc_magic MAGIC "$@"
}

# YAML parsing library
#
# usage: rmc_yaml VERSION [BASE]
#    or: rmc_yaml DIRECTORY
#    or: rmc_yaml system (or "yes")
#    or: rmc_yaml no
#
export RMC_YAML_BASEDIR=
export RMC_YAML_VERSION=
export RMC_YAML_ROOT=
rmc_yaml() {
    parse_version_or directory rmc_yaml YAML "$@"
}

# dlib
#
# usage: rmc_dlib VERSION [BASE]
#    or: rmc_dlib DIRECTORY
#    or: rmc_dlib system (or "yes")
#    or: rmc_dlib no
#
export RMC_DLIB_BASEDIR=
export RMC_DLIB_VERSION=
export RMC_DLIB_ROOT=
rmc_dlib() {
    parse_version_or directory rmc_dlib DLIB "$@"
}

# doxygen executable
#
# usage: rmc_doxygen VERSION [BASE]
#    or: rmc_doxygen DIRECTORY
#    or: rmc_doxygen system (or "yes")
#    or: rmc_doxygen no
#
export RMC_DOXYGEN_BASEDIR=
export RMC_DOXYGEN_VERSION=
export RMC_DOXYGEN_ROOT=
rmc_doxygen() {
    parse_version_or file rmc_doxygen DOXYGEN "$@"
}

# cmake executable
#
# usage: rmc_cmake VERSION [BASE]
#    or: rmc_cmake DIRECTORY
#    or: rmc_cmake system (or "yes")
#    or: rmc_cmake no
#
export RMC_CMAKE_BASEDIR=
export RMC_CMAKE_VERSION=
export RMC_CMAKE_ROOT=
rmc_cmake() {
    parse_version_or file rmc_cmake CMAKE "$@"
}

# python executable
#
# usage: rmc_python VERSION [BASE]
#    or: rmc_python DIRECTORY
#    or: rmc_python system (or "yes")
#    or: rmc_python no
#
export RMC_PYTHON_BASEDIR=
export RMC_PYTHON_VERSION=
export RMC_PYTHON_ROOT=
rmc_python() {
    parse_version_or file rmc_python PYTHON "$@"
}

# Qt widget library
#
# usage: rmc_qt VERSION [BASE]
#    or: rmc_qt DIRECTORY
#    or: rmc_qt system (or "yes")
#    or: rmc_qt no
#
export RMC_READLINE_BASEDIR=
export RMC_READLINE_VERSION=
export RMC_READLINE_ROOT=
rmc_qt() {
    parse_version_or directory rmc_qt QT "$@"
}

# Readline input library
#
# usage: rmc_readline VERSION [BASE]
#    or: rmc_readline DIRECTORY
#    or: rmc_readline system (or "yes")
#    or: rmc_readline no
#
export RMC_READLINE_BASEDIR=
export RMC_READLINE_VERSION=
export RMC_READLINE_ROOT=
rmc_readline() {
    parse_version_or directory rmc_readline READLINE "$@"
}

# SQLite database library
#
# usage: rmc_sqlite VERSION [BASE]
#    or: rmc_sqlite DIRECTORY
#    or: rmc_sqlite system (or "yes")
#    or: rmc_sqlite no
#
export RMC_SQLITE_BASEDIR=
export RMC_SQLITE_VERSION=
export RMC_SQLITE_ROOT=
rmc_sqlite() {
    parse_version_or directory rmc_sqlite SQLITE "$@"
}

# Yices SMT solver
#
# usage: rmc_yices VERSION [BASE]
#    or: rmc_yices DIRECTORY
#    or: rmc_yices system (or "yes")
#    or: rmc_yices no
#
export RMC_YICES_BASEDIR=
export RMC_YICES_VERSION=
export RMC_YICES_ROOT=
rmc_yices() {
    parse_version_or directory rmc_yices YICES "$@"
}

# Directory containing libjvm.so
export RMC_LIBJVM_ROOT=

############################################################################
# Functions to finalize config commands. These generally need to execute
# in the order listed here.

resolve() {
    resolve_source_dir
    resolve_build_dir
    resolve_install
    resolve_parallelism
    resolve_cmake
    resolve_compiler
    resolve_languages
    resolve_boost
    resolve_web_toolkit
    resolve_magic
    resolve_yaml
    resolve_dlib
    resolve_yices
    resolve_python
    resolve_libjvm
    resolve_readline
    resolve_sqlite
    resolve_qt
    resolve_so_paths
    resolve_doxygen
}

resolve_source_dir() {
    if [ "$RMC_SOURCE_DIR" = "" ]; then
        echo "$arg0: source directory is not specified" >&2
        exit 1
    elif [ ! -d "$RMC_SOURCE_DIR" ]; then
        echo "$arg0: source directory is missing: $RMC_SOURCE_DIR" >&2
        exit 1
    fi

    # Backward compatibility
    export RG_SRC="$RMC_SOURCE_DIR"
    export RG_BLD="$RMC_BUILD_DIR"
    export ROSE_SOURCE="$RMC_SOURCE_DIR"
    export ROSE_BUILD="$RMC_BUILD_DIR"
}       

resolve_build_dir() {
    local dir=$(top_blddir)
    if [ "$dir" = "" ]; then
        echo "$arg0: cannot find build directory" >&2
        exit 1
    fi
    RMC_BUILD_DIR="$dir"
}

resolve_install() {
    case "$RMC_PREFIX" in
        ""|yes)
            RMC_PREFIX="$RMC_BUILD_DIR/installed"
            ;;
        no)
            RMC_PREFIX="/DO_NOT_INSTALL"
            ;;
        *)
            RMC_PREFIX=$(cd "$RMC_BUILD_DIR" && realpath -s "$RMC_PREFIX")
            ;;
    esac
}

resolve_parallelism() {
    case "$RMC_PARALLELISM" in
        ""|system)
            local nprocs=$(sed -n '/^processor[ \t]*:/p' /proc/cpuinfo |wc -l)
            [ -n "$nprocs" ] || nprocs=1
            RMC_PARALLELISM="$nprocs"
            ;;
        unlimited|[0-9]*[0-9])
            : fine as is
            ;;
        *)
            echo "$arg0: invalid parallelism: '$RMC_PARALLELISM'" >&2
            ;;
    esac
}

resolve_compiler() {
    # Figure out the compiler executable regardless of version required. Don't try to hard to follow symlinks, or
    # we might end up invoking something like ccache directly (in which case version numbers will be wrong).
    [ "$RMC_CXX" = "" ] && RMC_CXX="g++"
    local cxx_realname=$(which "$RMC_CXX")
    if [ "$cxx_realname" = "" ]; then
	echo "$arg0: no such compiler command in path: $RMC_CXX" >&2
	exit 1
    fi

    # Get the compiler version number from its command
    local have_version=$("$cxx_realname" --version |\
				head -n1 |\
				perl -ne '/(\d+(\.\d+){1,2})$/ && print $1')
    if [ "$have_version" = "" ]; then
        echo "$arg0: cannot obtain version number from $cxx_realname" >&2
        exit 1
    fi

    # If a version number was specified, then make sure it matches the one we found
    if [ "$RMC_CXX_VERSION" != "" ]; then
	if [ "$RMC_CXX_VERSION" != "$have_version" ]; then
	    echo "$arg0: compiler version mismatch; have $have_version but need $RMC_CXX_VERSION" >&2
	    exit 1
	fi
    fi

    # Update global variables
    RMC_CXX="$cxx_realname"
    RMC_CXX_BASENAME=$(basename "$cxx_realname" |perl -pe 's/-\d+(\.\d+)+//')
    RMC_CXX_VERSION="$have_version"
}

resolve_languages() {
    if [ "$RMC_LANGUAGES" = "" ]; then
	echo "$arg0: warning: no frontend languages configured; ROSE will not be too useful" >&2
    fi
}

resolve_boost() {
    if [ "$RMC_BOOST_VERSION" = "system" ]; then
        echo "$arg0: do not use system-installed boost" >&2
        exit 1
    elif [ "$RMC_BOOST_ROOT" != "" ]; then
        find_version BOOST
        RMC_BOOST_ROOT=$(realpath "$RMC_BOOST_ROOT")
    elif [ "$RMC_BOOST_VERSION" != "" ]; then
        find_root BOOST
    else
        echo "$arg0: boost is required (use rmc_boost)" >&2
        exit 1
    fi

    add_library_path BOOST lib
}

resolve_web_toolkit() {
    if [ "$RMC_WT_VERSION" = "system" ]; then
        echo "$arg0: do not use system-insalled Wt" >&2
        exit 1
    elif [ "$RMC_WT_ROOT" != "" ]; then
        find_version WT Wt
        RMC_WT_ROOT=$(realpath "$RMC_WT_ROOT")
    elif [ "$RMC_WT_VERSION" != "" ]; then
        find_root WT Wt
    fi

    add_library_path WT lib
}

resolve_magic() {
    if [ "$RMC_MAGIC_ROOT" != "" ]; then
        find_version MAGIC
        RMC_MAGIC_ROOT=$(realpath "$RMC_MAGIC_ROOT")
    elif [ "$RMC_MAGIC_VERSION" != "" ]; then
        find_root MAGIC
    fi

    add_library_path MAGIC lib
}

resolve_yaml() {
    if [ "$RMC_YAML_ROOT" != "" ]; then
        find_version YAML
        RMC_YAML_ROOT=$(realpath "$RMC_YAML_ROOT")
    elif [ "$RMC_YAML_VERSION" != "" ]; then
        find_root YAML
    fi

    add_library_path YAML lib
}

resolve_dlib() {
    if [ "$RMC_DLIB_ROOT" != "" ]; then
        find_version DLIB
        RMC_DLIB_ROOT=$(realpath "$RMC_DLIB_ROOT")
    elif [ "$RMC_DLIB_VERSION" != "" ]; then
        find_root DLIB
    fi
}

resolve_yices() {
    if [ "$RMC_YICES_ROOT" != "" ]; then
        find_version YICES
        RMC_YICES_ROOT=$(realpath "$RMC_YICES_ROOT")
    elif [ "$RMC_YICES_VERSION" != "" ]; then
        find_root YICES
    fi
}

resolve_doxygen() {
    if [ "$RMC_DOXYGEN_ROOT" != "" ]; then
        find_version DOXYGEN
        RMC_DOXYGEN_ROOT=$(realpath "$RMC_DOXYGEN_ROOT")
    elif [ "$RMC_DOXYGEN_VERSION" != "" ]; then
        find_root DOXYGEN
    fi
}

resolve_cmake() {
    if [ "$RMC_CMAKE_ROOT" != "" ]; then
        find_version CMAKE
        RMC_CMAKE_ROOT=$(realpath "$RMC_CMAKE_ROOT")
    elif [ "$RMC_CMAKE_VERSION" != "" ]; then
        find_root CMAKE
    fi
}

resolve_python() {
    if [ "$RMC_PYTHON_ROOT" != "" ]; then
        find_version PYTHON
        RMC_PYTHON_ROOT=$(realpath "$RMC_PYTHON_ROOT")
    elif [ "$RMC_PYTHON_VERSION" != "" ]; then
        find_root PYTHON
    fi
}

resolve_libjvm() {
    if [ "$RMC_LIBJVM_ROOT" = "" ]; then
        local javac=$(realpath $(which javac))
        [ "$javac" = "" ] && exit 1
        local bindir="${javac%/*}"
        local libdir=$(realpath "$bindir/../jre")
        local libjvm=$(find "$libdir" -name 'libjvm.so' |head -n1)
        RMC_LIBJVM_ROOT="${libjvm%/*}"
        if [ ! -d "$RMC_LIBJVM_ROOT" ]; then
            echo "$arg0: cannot find libjvm.so" >&2
            exit 1
        fi
    else
        if [ ! -d "$RMC_LIBJVM_ROOT" ]; then
            echo "$arg0: libjvm directory is not valid: $RMC_LIBJVM_ROOT" >&2
            exit 1
        fi
        RMC_LIBJVM_ROOT=$(realpath "$RMC_LIBJVM_ROOT")
    fi

    add_library_path LIBJVM .
}

resolve_readline() {
    if [ "$RMC_READLINE_ROOT" != "" ]; then
        find_version READLINE
        RMC_READLINE_ROOT=$(realpath "$RMC_READLINE_ROOT")
    elif [ "$RMC_READLINE_VERSION" != "" ]; then
        find_root READLINE
    fi

    add_library_path READLINE
}

resolve_sqlite() {
    if [ "$RMC_SQLITE_ROOT" != "" ]; then
        find_version SQLITE SQLite3
        RMC_SQLITE_ROOT=$(realpath "$RMC_SQLITE_ROOT")
    elif [ "$RMC_SQLITE_VERSION" != "" ]; then
        find_root SQLITE SQLite3
    fi

    add_library_path SQLITE
}

resolve_qt() {
    if [ "$RMC_QT_ROOT" != "" ]; then
        find_version QT Qt
        RMC_QT_ROOT=$(realpath "$RMC_QT_ROOT")
    elif [ "$RMC_QT_VERSION" != "" ]; then
        find_root QT Qt
    fi

    add_library_path QT
}

resolve_so_paths() {
    # These are necessary if you want to run an executable directly without going through
    # the GNU libtool shell scripts. It's sometimes necessary if you want to use GDB
    # on a program that hasn't been installed yet (on the other hand, nemiver seems to
    # be able to debug through the libtool script).
    for f in src/.libs \
             libltdl/.libs \
             src/3rdPartyLibraries/libharu-2.1.0/src/.libs \
             src/3rdPartyLibraries/qrose/QRoseLib/.libs; do
        eval $(path-adjust --var=LD_LIBRARY_PATH --prepend --move insert "$RMC_BUILD_DIR/$f")
    done
}


############################################################################
#                        Sub-commands
############################################################################

# Subcommand to run a command in a build environment
do_shell() {
    load_configuration
    export PS1_STACK="${RMC_BUILD_DIR##*/} $PS1_STACK"

    if [ "$#" -eq 0 ]; then
        exec $SHELL
    else
        exec "$@"
    fi
    echo "$arg0: exec failed:" "$@" >&2
    exit 1
}

# Subcommand to create and initialize a build tree
do_init() {
    local force
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --force)
                force=yes
                shift
                ;;
            -*)
                echo "$arg0: unknown init switch: '$1'" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done

    if [ "$#" -ne 2 ]; then
        echo "usage: $arg0 $COMMAND BLDDIR SRCDIR" >&2
        exit 1
    fi

    local blddir="$1" srcdir="$2"
    if [ ! -d "$srcdir" ]; then
        echo "$arg0 $COMMAND: source directory does not exist: $srcdir" >&2
        exit 1
    fi
    srcdir=$(realpath "$srcdir")
    if [ -d "$blddir" ]; then
        if [ "$force" = "" ]; then
            echo "$arg0 $COMMAND: refusing to initialize existing build directory" >&2
            exit 1
        fi
    else
        mkdir -p "$blddir" || exit 1
    fi

    local config="$blddir/.rmc-main.cfg"
    (
        echo "# ROSE meta config (auto generated) -*- shell-script -*-"
        echo "#-------------------------------------------------------"
        echo
        echo "#----------------------------------"
        echo "#         General stuff"
        echo "#----------------------------------"
        echo
        echo "# Build system is either 'cmake' or 'autoconf'"
        echo "rmc_build_system autoconf"
        echo
        echo "# Installation prefix for 'make install'. The argument is"
        echo "#   absolute path   -- install into the specified path"
        echo "#   relative path   -- installation prefix w.r.t. build directory"
        echo "#   'yes' (default) -- build-relative directory named 'installed'"
        echo "#   'no'            -- installation is not supported"
        echo "rmc_install      yes"
        echo
        echo "# Maximum parallelism for things like 'make' commands."
        echo "#   positive number -- limit parallelism to specified value"
        echo "#   'system' (dflt) -- use number of compute cores as the limit"
        echo "#   'unlimited'     -- no hard limit on parallelism"
        echo "rmc_parallelism  system"
	echo
	echo "# Language frontends. The argument should be a comma-separated list"
	echo "# of language names with no intervening white space.  Possible languages"
	echo "# are 'all', 'non', 'binaries', 'c', 'c++', 'cuda', 'fortran', 'java'"
	echo "# 'x10', 'opencl', 'php', 'matlab', and 'python'."
	echo "rmc_languages    all"
        echo
        echo
        echo "#----------------------------------"
        echo "#         Compiling"
        echo "#----------------------------------"
        echo
        echo "# Comand that runs the C++ compiler.  Relative names are searched"
        echo "# according to the \$PATH environment variable."
        echo "rmc_compiler     g++"
        echo
        echo "# Whether ('yes' or 'no') to generate symbol tables useful for debugging"
        echo "# with tools like GDB. The default is 'yes'. Debugging support and"
        echo "# optimization are orthogonal issues."
        echo "rmc_debug        yes"
        echo
        echo "# Whether ('yes' or 'no') to add optimization switches to compiler"
        echo "# commands. If 'no' then optimizations are explicitly turned off, which"
        echo "# can be useful for debugging since C++ statements will generally have"
        echo "# the same order as the binary instructions."
        echo "rmc_optimize     yes"
        echo
        echo "# Whether ('yes' or 'no') to cause the C++ compiler to emit warnings"
        echo "# about questionable source code."
        echo "rmc_warnings     yes"
        echo
        echo "# Behavior of Sawyer ASSERT_... macros."
        echo "#   'abort' (dflt)-- message emitted, then abort process"
        echo "#   'exit'        -- message emitted, then exit with non-zero status"
        echo "#   'throw'       -- exception thrown, which contains the message"
        echo "rmc_assertions   abort"
        echo
        echo
        echo "#----------------------------------"
        echo "#         Additional software"
        echo "#----------------------------------"
        echo
        echo "# These directives all take the same kinds of arguments:"
        echo "#   'no'          -- ROSE should not use this software"
        echo "#   'system'      -- Use the publicly installed version; a.k.a. 'yes'"
        echo "#   directory     -- Look in the directory for includes and libs"
        echo "#   file          -- Use the specified file (not for libraries)"
        echo "#   vesion        -- Look for a particular version"
        echo "#   version base  -- Same, but use specified base directory"
        echo "# If a version is specified without a base directory then this"
        echo "# script searches certain well-known locations. Versioned software"
        echo "# directories follow a specific naming scheme which incorporates"
        echo "# information about their dependencies, therefore specifying software"
        echo "# by version number is the safest way to make sure all software is"
        echo "# configured consistently."
        echo
        echo "rmc_boost        1.50"
	echo "rmc_cmake        system"
        echo "rmc_dlib         18.10"
	echo "rmc_doxygen      1.8.1"
        echo "rmc_magic        system"
        echo "rmc_python       /usr/bin/python3"
        echo "rmc_qt           no"
        echo "rmc_readline     6.3"
        echo "rmc_sqlite       system"
        echo "rmc_web_toolkit  3.3.3"
        echo "rmc_yaml         0.5.1"
        echo "rmc_yices        1.0.34"
        echo
        echo
        echo "#----------------------------------"
        echo "#         Tool options"
        echo "#----------------------------------"
        echo
        echo "# Not used yet"
        echo "rmc_checks       binary"
        echo
        echo "#-------------------------------------------------------"
        echo "RMC_SOURCE_DIR='$srcdir'"
    ) >$config

    ${EDITOR} $config

    (cd $blddir && do_shell)
}

# Subcommand to configure the build directory (autoconf, cmake, etc)
do_config() {
    local cmd dry_run
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --dry-run)
                dry_run="--dry-run"
                shift
                ;;
            -*)
                echo "$arg0 $COMMAND: unknown switch: '$1'" >&2
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    load_configuration

    case "$RMC_BUILD_SYSTEM" in
        ""|autoconf)
            local debug optim cxx_warn c_warn

            [ "$RMC_DEBUG" = "yes" ] && debug="-g"

            case "$RMC_OPTIM" in
                yes)
                    optim="'-O3 -fomit-frame-pointer -DNDEBUG'"
                    ;;
                *)
                    optim="-O0"
                    ;;
            esac

            case "$RMC_WARN" in
                yes)
                    cxx_warn="'-Wall -Wno-unused-local-typedefs'"
                    c_warn="-Wall"
                    ;;
                *)
                    cxx_warn=
                    c_warn=
                    ;;
            esac

            # Qt detections is somewhat broken in ROSE's config system. For one thing, it doesn't
	    # understand "--without-qt"
            qt_flags=$(configure_with QT)
	    if [ "$qt_flags" = "--without-qt" ]; then
		qt_flags=
	    else
                qt_flags="$qt_flags --with-qt-lib --with-roseQt"
            fi
            

	    (
		set -e
		cd "$RMC_BUILD_DIR"
		execute $dry_run \
			$RMC_SOURCE_DIR/configure \
			--disable-boost-version-check \
			--enable-assertion-behavior=$RMC_ASSERTIONS \
			--enable-edg_union_struct_debugging \
		        --enable-languages="$RMC_LANGUAGES" \
			--enable-rosehpc \
			--prefix="$RMC_PREFIX" \
			--with-CFLAGS=-fPIC \
			--with-CXXFLAGS=-fPIC \
			--with-CXX_DEBUG="$debug" \
			--with-CXX_OPTIMIZE="$optim" \
			--with-CXX_WARNINGS="$cxx_warn" \
			--with-C_DEBUG="$debug" \
			--with-C_OPTIMIZE="$optim" \
			--with-C_WARNINGS="$c_warn" \
			--with-ROSE_LONG_MAKE_CHECK_RULE=yes \
			--with-boost="$RMC_BOOST_ROOT" \
			$(configure_with DLIB) \
		        $(configure_with DOXYGEN doxygen bin/doxygen) \
			--with-edg_source_code=true \
			--with-java=/usr/lib/jvm/java-7-sun \
			$(configure_with READLINE libreadline) \
			$(configure_with MAGIC) \
			--with-pch \
			$(configure_with PYTHON python bin/python) \
			$qt_flags \
			$(configure_with SQLITE sqlite3) \
			$(configure_with WT) \
			$(configure_with YAML) \
			$(configure_with YICES)
	    )
            ;;
        cmake)
	    local cmake_build_type
	    if [ "$RMC_OPTIM" = "yes" ]; then
		if [ "$RMC_DEBUG" = "yes" ]; then
		    echo "$arg0: warning: cmake builds cannot handle optimize + debug (assuming only optimize)" >&2
		fi
		cmake_build_type="Release"
	    elif [ "$RMC_DEBUG" = "yes" ]; then
		cmake_build_type="Debug"
	    else
		echo "$arg0: warning: camek builds cannot handle non-optimize + non-debug (assuming only debug)" >&2
		cmake_build_type="Debug"
	    fi

	    (
		set -e
		cd "$RMC_BUILD_DIR"
		execute $dry_run $(find_prefix CMAKE cmake bin/cmake) "$RMC_SOURCE_DIR" \
		    -DCMAKE_BUILD_TYPE="$cmake_build_type" \
		    -DCMAKE_INSTALL_PREFIX="$RMC_PREFIX" \
		    -DASSERTION_BEHAVIOR="$RMC_ASSERTIONS" \
		    $(cmake_Droot BOOST) \
		    $(cmake_Droot DLIB) \
		    $(cmake_Droot DOXYGEN doxygen bin/doxygen) \
		    $(cmake_Droot READLINE) \
		    $(cmake_Droot MAGIC) \
		    $(cmake_Droot SQLITE) \
		    $(cmake_Droot YAML) \
		    $(cmake_Droot YICES with-yices) \
		    $(cmake_Droot WT) \
		    -Denable-cuda:BOOL=OFF
	    )
	    ;;

        *)
            echo "$arg0 $COMMAND: unknown build system: $RMC_BUILD_SYSTEM'" >&2
            exit 1
            ;;
    esac
}

do_make() {
    local where="$1"; shift
    load_configuration

    # Parse "make" switches, keeping track of a couple special ones.
    local make_switches=()
    local have_C have_j dry_run
    while [ "$#" -gt 0 ]; do
        case "$1" in
            --dry-run)
                # Steal this for ourselves. Users can still run "make"
                # the normal way if they really want --dry-run to be
                # for the "make" command.
                dry_run="--dry-run"
                shift
                ;;
            -C|--directory)
                make_switches=("${make_swithces[@]}" "$1" "$2")
                have_C="$1 $2"
                shift; shift
                ;;
            --directory=*)
                make_switches=("${make_switches[@]}" "$1")
                have_C="$1"
                shift
                ;;
            -j|--jobs)
                case "$2" in
                    [0-9]*[0-9])
                        have_j="$1 $2"
                        shift; shift
                        ;;
                    *)
                        have_j="$1"
                        shift
                        ;;
                esac
                ;;
            -j*)
                have_j="$1"
                shift
                ;;
            --jobs=*)
                have_j="$1"
                shift
                ;;
            --debug|-f|--file|--makefile|-I|--include-dir|-l|--load-average|-o|--old-file|--assume-old|-O|--output-sync|-W|--what-if|--new-file|--assume-new)
                # These all take an argument
                make_switches=("${make_swithces[@]}" "$1" "$2")
                shift; shift
                ;;
            -*)
                # These take no arguments
                make_switches=("${make_switches[@]}" "$1")
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    local targets=("$@")
    if [ "${#targets[*]}" -eq 0 ]; then
        targets=(all)
    fi

    # Choose the directories were we'll run "make"
    local dirs=()
    case "$where" in
        binary)
            dirs=("-C $RMC_BUILD_DIR/src"
                  "-C $RMC_BUILD_DIR/tests/roseTests/binaryTests"
                  "-C $RMC_BUILD_DIR/projects/BinaryAnalysisTools"
		  "-C $RMC_BUILD_DIR/projects/simulator2"
		  "-C $RMC_BUILD_DIR/projects/BinaryCloneDetection"
	    )
            ;;
        here)
            dirs=("")
	    have_C=
            ;;
        lib)
            dirs=("-C $RMC_BUILD_DIR/src")
            ;;
        *)
            echo "$arg0 $COMMAND: unknown location: '$where'" >&2
            exit 1
            ;;
    esac
    if [ "$have_C" != "" ]; then
        echo "$arg0 $COMMAND: '$have_C' is incompatible with this command" >&2
        exit 1
    fi

    # Figure out the parallelism.  The "-j" etc. switches will override
    # the values from our own configuration files.
    local parallelism
    if [ "$have_j" != "" ]; then
        parallelism="$have_j"
    elif [ "$RMC_PARALLELISM" = "unlimited" ]; then
        parallelism="-j"
    else
        parallelism="-j$RMC_PARALLELISM"
    fi

    # Run "make" in each directory for each target.
    for target in "${targets[@]}"; do
        for dir in "${dirs[@]}"; do
            # Use --silent because ROSE's autoconf- and cmake-generated
            # maekfiles generally print their own output anyway. Otherwise
            # "make" is so noisy that warning messages tend to get overlooked
            execute $dry_run make $parallelism --silent "$dir" "${make_switches[@]}" "$target" \
                || exit 1
        done
    done
    return 0
}

    
############################################################################
#                      Parse global switches
############################################################################

command=
while [ "$#" -gt 0 ]; do
    case "$1" in
        -*)
            echo "$arg0: unknown global switch: '$1'" >&2
            exit 1
            ;;
        *)
            COMMAND="$1"
            shift
            break
            ;;
    esac
done

case "$COMMAND" in
    init)
        do_init "$@"
        ;;
    config)
        do_config "$@"
        ;;
    make)
        do_make "here" "$@"
        ;;
    make-*)
	do_make "${COMMAND#build-}" "$@"
	;;
    shell)
        do_shell "$@"
        ;;
    "")
        do_shell
        ;;
    *)
        do_shell "$COMMAND" "$@"
        ;;
esac
